import unittest
import requests
import json
import uuid
import logging
from datetime import datetime, timedelta

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class TestVulnerabilityData(unittest.TestCase):
    """Test class for verifying vulnerability data shown on the Results page"""
    
    BASE_URL = "http://localhost:3000/api"
    
    def setUp(self):
        """Set up test by registering a test agent and creating test tasks with vulnerabilities"""
        # Generate unique identifiers for this test run
        self.test_run_id = str(uuid.uuid4())[:8]
        self.agent_id = str(uuid.uuid4())
        self.agent_name = f"test-agent-{self.test_run_id}"
        
        # Register a test agent
        agent_data = {
            "agent_id": self.agent_id,
            "agent_name": self.agent_name,
            "capabilities": ["bandit", "semgrep", "gitleaks"],
            "system_info": {
                "platform": "linux",
                "python": "3.10.0",
                "hostname": "test-host"
            }
        }
        
        response = requests.post(f"{self.BASE_URL}/agents/register", json=agent_data)
        self.assertEqual(response.status_code, 200, f"Failed to register test agent: {response.text}")
        
        # Create task data
        self.task_data = {
            "agent_id": self.agent_id,
            "repository_url": f"https://github.com/test/security-vulnerabilities-{self.test_run_id}",
            "branch": "main",
            "scanners": ["bandit", "semgrep", "gitleaks"]
        }
        
        # Create test tasks with vulnerabilities of different severities
        self.create_tasks_with_vulnerabilities()
    
    def create_tasks_with_vulnerabilities(self):
        """Create test tasks with different types of vulnerabilities"""
        # Create a task
        response = requests.post(f"{self.BASE_URL}/tasks", json=self.task_data)
        self.assertEqual(response.status_code, 200, f"Failed to create task: {response.text}")
        self.task_id = response.json()["task"]["id"]
        
        # Update to running status
        response = requests.patch(
            f"{self.BASE_URL}/tasks/{self.task_id}",
            json={"status": "running"}
        )
        self.assertEqual(response.status_code, 200, f"Failed to update task status: {response.text}")
        
        # Submit scan results with a variety of vulnerabilities
        scan_results = {
            "task_id": self.task_id,
            "agent_id": self.agent_id,
            "status": "completed",
            "start_time": (datetime.now() - timedelta(minutes=5)).isoformat(),
            "end_time": datetime.now().isoformat(),
            "scan_results": {
                "bandit": {
                    "success": True,
                    "exit_code": 0,
                    "results": {
                        "results": [
                            # High severity
                            {
                                "code": "subprocess.call(['ls', user_input], shell=True)",
                                "filename": "app/server.py",
                                "issue_confidence": "HIGH",
                                "issue_severity": "HIGH",
                                "issue_text": "Subprocess call with shell=True seems safe, but may be vulnerable to shell injection",
                                "line_number": 42,
                                "test_id": "B602",
                                "test_name": "subprocess_popen_with_shell_equals_true"
                            },
                            # Medium severity
                            {
                                "code": "print('Password: ' + password)",
                                "filename": "app/auth.py",
                                "issue_confidence": "MEDIUM",
                                "issue_severity": "MEDIUM",
                                "issue_text": "Possible hardcoded password",
                                "line_number": 28,
                                "test_id": "B105",
                                "test_name": "hardcoded_password_string"
                            },
                            # Low severity
                            {
                                "code": "yaml.load(user_yaml)",
                                "filename": "app/config.py",
                                "issue_confidence": "HIGH",
                                "issue_severity": "LOW",
                                "issue_text": "Use of unsafe yaml.load(). Allows instantiation of arbitrary objects",
                                "line_number": 15,
                                "test_id": "B506",
                                "test_name": "yaml_load"
                            }
                        ]
                    }
                },
                "semgrep": {
                    "success": True,
                    "exit_code": 0,
                    "results": {
                        "results": [
                            # High severity
                            {
                                "check_id": "python.lang.security.dangerous-eval.dangerous-eval",
                                "path": "app/utils.py",
                                "start": {"line": 22, "col": 5},
                                "end": {"line": 22, "col": 20},
                                "extra": {
                                    "message": "Avoid using eval",
                                    "severity": "high",
                                    "lines": "eval(user_input)",
                                    "metadata": {
                                        "cwe": "CWE-95"
                                    }
                                }
                            },
                            # Medium severity
                            {
                                "check_id": "python.django.security.audit.xss.template-autoescape-off",
                                "path": "app/templates/index.html",
                                "start": {"line": 8, "col": 2},
                                "end": {"line": 8, "col": 25},
                                "extra": {
                                    "message": "Autoescape off is dangerous",
                                    "severity": "medium",
                                    "lines": "{% autoescape off %}",
                                    "metadata": {
                                        "cwe": "CWE-79"
                                    }
                                }
                            }
                        ]
                    }
                },
                "gitleaks": {
                    "success": True,
                    "exit_code": 0,
                    "results": {
                        "findings": [
                            {
                                "description": "AWS API Key",
                                "secret": "AKIAIOSFODNN7EXAMPLE",
                                "file": "app/aws_client.py",
                                "line": 12,
                                "offender": "AKIAIOSFODNN7EXAMPLE",
                                "date": "2023-01-15T12:00:00Z",
                                "author": "developer@example.com",
                                "email": "developer@example.com",
                                "fingerprint": "aws-api-key-12345",
                                "severity": "high"
                            }
                        ]
                    }
                }
            }
        }
        
        response = requests.post(f"{self.BASE_URL}/tasks/{self.task_id}/results", json=scan_results)
        self.assertEqual(response.status_code, 200, f"Failed to submit scan results: {response.text}")
    
    def test_vulnerability_summary(self):
        """Test that vulnerability summary on Results page is accurate"""
        # Get vulnerabilities
        response = requests.get(f"{self.BASE_URL}/tasks/{self.task_id}/vulnerabilities")
        self.assertEqual(response.status_code, 200, f"Failed to get vulnerabilities: {response.text}")
        
        vulnerabilities = response.json()["vulnerabilities"]
        
        # Verify we have the expected number of vulnerabilities
        # 3 from Bandit + 2 from Semgrep + 1 from Gitleaks = 6
        self.assertEqual(len(vulnerabilities), 6, "Expected exactly 6 vulnerabilities")
        
        # Check for correct counts by severity
        high_vulns = [v for v in vulnerabilities if v["severity"] == "high"]
        medium_vulns = [v for v in vulnerabilities if v["severity"] == "medium"]
        low_vulns = [v for v in vulnerabilities if v["severity"] == "low"]
        
        self.assertEqual(len(high_vulns), 3, "Expected exactly 3 high severity vulnerabilities")
        self.assertEqual(len(medium_vulns), 2, "Expected exactly 2 medium severity vulnerabilities")
        self.assertEqual(len(low_vulns), 1, "Expected exactly 1 low severity vulnerability")
    
    def test_vulnerability_details(self):
        """Test that vulnerability details on Results page are accurate"""
        # Get vulnerabilities
        response = requests.get(f"{self.BASE_URL}/tasks/{self.task_id}/vulnerabilities")
        self.assertEqual(response.status_code, 200, f"Failed to get vulnerabilities: {response.text}")
        
        vulnerabilities = response.json()["vulnerabilities"]
        
        # Verify data structure for each vulnerability type
        for vuln in vulnerabilities:
            # Common fields all vulnerabilities should have
            self.assertIn("id", vuln)
            self.assertIn("scanner", vuln)
            self.assertIn("severity", vuln)
            self.assertIn("file_path", vuln)
            self.assertIn("line_number", vuln)
            self.assertIn("message", vuln)
            self.assertIn("description", vuln)
            self.assertIn("created_at", vuln)
            
            # Scanner-specific checks
            if vuln["scanner"] == "bandit":
                # Verify Bandit-specific fields
                if "subprocess" in vuln["message"].lower():
                    self.assertEqual(vuln["severity"], "high")
                    self.assertEqual(vuln["file_path"], "app/server.py")
                    self.assertEqual(vuln["line_number"], 42)
                elif "hardcoded_password" in vuln["description"].lower():
                    self.assertEqual(vuln["severity"], "medium")
                    self.assertEqual(vuln["file_path"], "app/auth.py")
                    self.assertEqual(vuln["line_number"], 28)
                elif "yaml_load" in vuln["description"].lower():
                    self.assertEqual(vuln["severity"], "low")
                    self.assertEqual(vuln["file_path"], "app/config.py")
                    self.assertEqual(vuln["line_number"], 15)
            
            elif vuln["scanner"] == "semgrep":
                # Verify Semgrep-specific fields
                if "eval" in vuln["message"].lower():
                    self.assertEqual(vuln["severity"], "high")
                    self.assertEqual(vuln["file_path"], "app/utils.py")
                    self.assertEqual(vuln["line_number"], 22)
                elif "autoescape" in vuln["message"].lower():
                    self.assertEqual(vuln["severity"], "medium")
                    self.assertEqual(vuln["file_path"], "app/templates/index.html")
                    self.assertEqual(vuln["line_number"], 8)
            
            elif vuln["scanner"] == "gitleaks":
                # Verify Gitleaks-specific fields
                self.assertEqual(vuln["severity"], "high")
                self.assertEqual(vuln["file_path"], "app/aws_client.py")
                self.assertEqual(vuln["line_number"], 12)
                self.assertIn("AWS", vuln["message"])
    
    def test_vulnerability_filtering(self):
        """Test that vulnerability filtering by severity works correctly"""
        # Test filtering by high severity
        response = requests.get(f"{self.BASE_URL}/tasks/{self.task_id}/vulnerabilities?severity=high")
        self.assertEqual(response.status_code, 200, f"Failed to get high severity vulnerabilities: {response.text}")
        
        high_vulns = response.json()["vulnerabilities"]
        self.assertEqual(len(high_vulns), 3, "Expected exactly 3 high severity vulnerabilities")
        
        # Test filtering by medium severity
        response = requests.get(f"{self.BASE_URL}/tasks/{self.task_id}/vulnerabilities?severity=medium")
        self.assertEqual(response.status_code, 200, f"Failed to get medium severity vulnerabilities: {response.text}")
        
        medium_vulns = response.json()["vulnerabilities"]
        self.assertEqual(len(medium_vulns), 2, "Expected exactly 2 medium severity vulnerabilities")
        
        # Test filtering by low severity
        response = requests.get(f"{self.BASE_URL}/tasks/{self.task_id}/vulnerabilities?severity=low")
        self.assertEqual(response.status_code, 200, f"Failed to get low severity vulnerabilities: {response.text}")
        
        low_vulns = response.json()["vulnerabilities"]
        self.assertEqual(len(low_vulns), 1, "Expected exactly 1 low severity vulnerability")
    
    def test_scan_results_data(self):
        """Test that scan results data on Results page is accurate"""
        # Get scan results
        response = requests.get(f"{self.BASE_URL}/tasks/{self.task_id}/results")
        self.assertEqual(response.status_code, 200, f"Failed to get scan results: {response.text}")
        
        scan_result = response.json()["result"]
        
        # Verify scan result data structure
        self.assertIn("id", scan_result)
        self.assertIn("task_id", scan_result)
        self.assertIn("agent_id", scan_result)
        self.assertIn("status", scan_result)
        self.assertIn("scan_results", scan_result)
        self.assertIn("start_time", scan_result)
        self.assertIn("end_time", scan_result)
        
        # Verify scan status is completed
        self.assertEqual(scan_result["status"], "completed")
        
        # Verify scan_results contains all scanner results
        self.assertIn("bandit", scan_result["scan_results"])
        self.assertIn("semgrep", scan_result["scan_results"])
        self.assertIn("gitleaks", scan_result["scan_results"])
        
        # Verify each scanner has success flag
        self.assertTrue(scan_result["scan_results"]["bandit"]["success"])
        self.assertTrue(scan_result["scan_results"]["semgrep"]["success"])
        self.assertTrue(scan_result["scan_results"]["gitleaks"]["success"])
    
    def tearDown(self):
        """Clean up test data"""
        # No cleanup necessary for read-only tests
        # In a real system, you might want to delete test data
        pass

if __name__ == "__main__":
    unittest.main() 